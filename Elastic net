library(glmnet)
library(ggplot2)

data <- read.csv("Data/Uppsaladata.CSV")

set.seed(42)

################################### Sample data

ind <- sample(2, nrow(data), replace=TRUE, prob = c(0.8, 0.2))
train.data <- data[ind==1,]
test.data <- data[ind==2,]

train.features <- train.data[, c("motor", "pupil", "age", "CT")]
x.train <- as.matrix(train.features)

test.features <- test.data[, c("motor", "pupil", "age", "CT")]
x.test <- as.matrix(test.features)

train.lable <- train.data[, c("eGOS")]
y.train <- as.matrix(train.lable)

test.lable <- test.data[, c("eGOS")]
y.test <- as.matrix(test.lable)

######################## Ridge regression (alpha = 0)

alpha0.fit <- cv.glmnet(x.train, y.train, type.measure="mse",
                        alpha=0, family="gaussian")

alpha0.predicted <-
  predict(alpha0.fit, s=alpha0.fit$lambda.1se, newx=x.test) #lambda.1se = optimal value for lambda in alpha0.fit

MSE.0 <- mean((y.test - alpha0.predicted)^2) #MSE for ridge regression
MAE.0 <- mean(abs(y.test - alpha0.predicted))


######################## Lasso regression (alpha = 1)
alpha1.fit <- cv.glmnet(x.train, y.train, type.measure="mse",
                        alpha=1, family="multinomial")

alpha1.predicted <-
  predict(alpha1.fit, s=alpha1.fit$lambda.1se, newx=x.test)

MSE.1 <- mean((y.test - alpha1.predicted)^2) #MSE for lasso regression
MAE.1 <- mean(abs(y.test - alpha1.predicted))

# Compare MSE to see which is best


####################### Elastic net regression (alpha = 0.5)

alpha0.5.fit <- cv.glmnet(x.train, y.train, type.measure="mse",
                          alpha=0.5, family="gaussian")

alpha0.5.predicted <-
  predict(alpha0.5.fit, s=alpha0.5.fit$lambda.1se, newx=x.test)

MSE.0.5 <-mean((y.test - alpha0.5.predicted)^2)
MAE.0.5 <- mean(abs(y.test - alpha0.5.predicted))

# Compare MSE of each three

###################### Finding optimal alpha value from 0.0 to 1.0 (combination of lasso and ridge regression)

list.of.fits <- list()
for (i in 0:10) {
  fit.name <- paste0("alpha", i/10) #creates names of alpha 0/10=0 to 1/10=1
  
  list.of.fits[[fit.name]] <-
    cv.glmnet(x.train, y.train, type.measure = "mse", alpha=i/10,
              family="gaussian")
}

results <- data.frame()
for (i in 0:10) {
  fit.name <- paste0("alpha", i/10)
  
  predicted <-
    predict(list.of.fits[[fit.name]],
            s=list.of.fits[[fit.name]]$lambda.1se, newx=x.test)
  
  mse <- mean((y.test - predicted)^2)
  
  temp <- data.frame(alpha=i/10, mse=mse, fit.name=fit.name)
  results <- rbind(results, temp)
}

results


eGOS <- round(predict(alpha0.fit, x.test))
head(eGOS)

############################## Optimal: alpha = 0
alpha0.fit <- cv.glmnet(x.train, y.train, type.measure="mse",
                          alpha=0, family="gaussian")

alpha0.predicted <-
  predict(alpha0.fit, s=alpha0.fit$lambda.1se, newx=x.test)
alpha0predicted


#############MSE

MSE0 <- mean((y.test - alpha0.predicted)^2)

######### MAE
numeric.test.y <- as.numeric(test.lable)
MAE0 <- mean(abs(numeric.test.y - alpha0.predicted))


##################################### Create confusion matrix

library(ggplot2)
library(reshape)

source("ConfusionMatrix_Count.R")
source("ConfusionMatrix_Normalize.R")
source("ConfusionMatrix_Plot.R")
source("ConfusionMatrix_GOSE.R")

actual.egos <- as.integer(y.test)
predicted.egos <- as.integer(alpha0.predicted)

confusion.matrix <- ConfusionMatrix_GOSE(actual.egos, predicted.egos)
confusion.matrix$Graph

#######################  ROC and AUC for unfavourable / mortality
library(pROC)

AUC.data <- predict(alpha0.fit, x.test)
prob.unfavourable <- rep(NA,nrow(AUC.data))
for(i in 1:nrow(AUC.data)){
  prob.sum <- sum(AUC.data[i, 1:4])
  prob.unfavourable[i] <- prob.sum
}
prob.favourable <- 1-prob.unfavourable

true.AUC.data <- as.numeric(y.test)
was.unfavourable <- true.AUC.data <=4
was.favourable <- !was.unfavourable


AUC.data <- predict(alpha0.fit, x.test)
prob.mortality <- rep(NA,nrow(AUC.data))
for(i in 1:nrow(AUC.data)){
  prob.sum <- sum(AUC.data[i, 1])
  prob.mortality[i] <- prob.sum
}

true.AUC.data.mortality <- as.numeric(y.test)
was.mortality <- true.AUC.data.mortality ==1


ROC.mortality <- roc(predictor = prob.mortality, response = was.mortality)


ROC.unfavourable <- roc(predictor = prob.unfavourable, response = was.unfavourable)

plot(ROC.unfavourable)
AUC.unfavorable <- auc(ROC.unfavourable)

plot(ROC.mortality)
AUC.mortality <- auc(ROC.mortality)


######################################### Testing on Leuven data
Leuvendata <- read.csv("Data/Leuvendata.CSV")

Leuven.test.features <- Leuvendata[, c("motor", "pupil", "age", "CT")]
Leuven.x.test <- as.matrix(Leuven.test.features)

Leuven.test.lable <- Leuvendata[, c("eGOS")]
Leuven.y.test <- as.matrix(Leuven.test.lable)


Leuven.alpha0.predicted <-
  predict(alpha0.fit, s=alpha0.fit$lambda.1se, newx=Leuven.x.test)

Leuven.MSE <-mean((Leuven.y.test - Leuven.alpha0.predicted)^2)
Leuven.MAE <- mean(abs(Leuven.y.test - Leuven.alpha0.predicted))

############################################################# ROC and AUC for unfavourable / mortality
library(pROC)

Leuven.AUC.data <- predict(alpha0.fit, Leuven.x.test)
Leuven.prob.unfavourable <- rep(NA,nrow(Leuven.AUC.data))
for(i in 1:nrow(Leuven.AUC.data)){
  prob.sum <- sum(Leuven.AUC.data[i, 1:4])
  Leuven.prob.unfavourable[i] <- prob.sum
}
Leuven.prob.favourable <- 1-Leuven.prob.unfavourable

Leuven.true.AUC.data <- as.numeric(Leuven.y.test)
Leuven.was.unfavourable <- Leuven.true.AUC.data <=4
Leuven.was.favourable <- !was.unfavourable


Leuven.prob.mortality <- rep(NA,nrow(Leuven.AUC.data))
for(i in 1:nrow(Leuven.AUC.data)){
  prob.sum <- sum(Leuven.AUC.data[i, 1])
  Leuven.prob.mortality[i] <- prob.sum
}

Leuven.true.AUC.data.mortality <- as.numeric(Leuven.y.test)
Leuven.was.mortality <- Leuven.true.AUC.data.mortality ==1


Leuven.ROC.mortality <- roc(predictor = Leuven.prob.mortality, response = Leuven.was.mortality)


Leuven.ROC.unfavourable <- roc(predictor = Leuven.prob.unfavourable, response = Leuven.was.unfavourable)

plot(Leuven.ROC.unfavourable)
Leuven.AUC.unfavorable <- auc(Leuven.ROC.unfavourable)

plot(Leuven.ROC.mortality)
Leuven.AUC.mortality <- auc(Leuven.ROC.mortality)

#confusion.matrix <- ConfusionMatrix_GOSE(actual.egos, original.predicted)
#confusion.matrix$Graph
########################original predicted without expansion factor
library(ggplot2)
library(reshape)

source("ConfusionMatrix_Count.R")
source("ConfusionMatrix_Normalize.R")
source("ConfusionMatrix_Plot.R")
source("ConfusionMatrix_GOSE.R")

Leuven.original.predicted <- as.integer(predict(model, Leuven.test.set))
Leuven.actual.egos <- as.integer(Leuven.test.set$eGOS)


confusion.matrix <- ConfusionMatrix_GOSE(Leuven.actual.egos, Leuven.original.predicted)
confusion.matrix$Graph

Leuven.MAE <- sum((abs(Leuven.original.predicted - Leuven.actual.egos))) / length(Leuven.actual.egos)
Leuven.MSE <- sum((Leuven.original.predicted - Leuven.actual.egos)^2) / length(Leuven.actual.egos)

# Functions for selecting a category based on the probabilities for each category.

SelectCategory_HighestProbability <- function(probabilities) {
  # Selects the category with the highest probability.
  
  # probabilities should be a matrix with 8 columns and one row per patient.
  
  # The return value is an integer vector with the predicted categories.
  
  VerifyArgumentsFor_SelectCategory_HighestProbability(probabilities)
  
  predictions <- apply(probabilities, 1, which.max)
  names(predictions) <- NULL
  
  return(predictions)
}

SelectCategory_WeightedAverage <- function(probabilities) {
  # Selects the category using the weighted average of the probabilities.
  
  # probabilities should be a matrix with 8 columns and one row per patient.
  
  # The return value is an integer vector with the predicted categories.
  
  VerifyArgumentsFor_SelectCategory_WeightedAverage(probabilities)
  
  weighted.average <- function(x) {
    as.integer(round(sum(x * 1:8)))
  }
  
  predictions <- apply(probabilities, 1, weighted.average)
  names(predictions) <- NULL
  
  return(predictions)
}

SelectCategory_Loess <- function(probabilities, span.setting) {
  # Selects the category by first fitting a line to the probabilities using loess.
  # The highest point of the line is then used to select the category.
  
  # probabilities should be a matrix with 8 columns and one row per patient.
  # span.setting is the span size used in the loess function.
  
  # The return value is an integer vector with the predicted categories.
  
  VerifyArgumentsFor_SelectCategory_Loess(probabilities, span.setting)
  
  predicted.categories <- rep(NA, nrow(probabilities))
  
  for (i in 1:nrow(probabilities)) {
    prob.data <- data.frame(x = 1:8, y = probabilities[i, ])
    
    line.model <- loess(
      y ~ x,
      data = prob.data,
      span = span.setting)
    
    x.vals <- seq(from = 1.0, to = 8.0, by = 0.1)
    y.vals <- predict(line.model, x.vals)
    
    peak.x <- x.vals[which.max(y.vals)]
    
    selected.category <- as.integer(round(peak.x))
    
    predicted.categories[i] <- selected.category
  }
  
  return(predicted.categories)
}

CreateLoessSelectionGraph <- function(patient.category.probabilities, span.setting) {
  # Creates a graph that visualizes category selction using loess.
  
  # patient.category.probabilities should be a vector of length 8
  # with the probabilities for each GOSE category for this particular patient.
  # span.setting is the span size used in the loess function.
  
  # The return value is a ggplot object of the graph.
  
  VerifyArgumentsFor_CreateLoessSelectionGraph(patient.category.probabilities, span.setting)
  
  library(ggplot2)
  
  prob.data <- data.frame(GOSE = 1:8, Probability = patient.category.probabilities)
  
  line.model <- loess(
    Probability ~ GOSE,
    data = prob.data,
    span = span.setting)
  
  x.vals <- seq(from = 1.0, to = 8.0, by = 0.1)
  y.vals <- predict(line.model, x.vals)
  
  peak.x <- x.vals[which.max(y.vals)]
  selected.category <- as.integer(round(peak.x))
  
  line.table <- data.frame(x = x.vals, y = y.vals)
  
  dot.color <- rep("black", 8)
  dot.color[selected.category] <- "red"
  
  y.min <- 0
  y.max <- max(c(patient.category.probabilities, y.vals))
  y.max <- (floor(y.max * 10) + 1) / 10
  
  loess.plot <- ggplot() + 
    geom_point(
      aes(x = GOSE, y = Probability),
      data = prob.data,
      color = dot.color,
      size = 2) +
    geom_line(
      data = line.table,
      aes(x = x, y = y)) +
    ylim(y.min, y.max) +
    scale_x_continuous(breaks = 1:8) +
    ylab("Probability") +
    xlab("GOS-E") +
    theme_classic() +
    theme(
      axis.title = element_text(size = 20),
      axis.text = element_text(size = 15))
  
  return(loess.plot)
}

VerifyArgumentsFor_SelectCategory_HighestProbability <- function(probabilities) {
  # Helper function that checks if the input to SelectCategory_HighestProbability are valid.
  
  base.error.message <- "Invalid argument to SelectCategory_HighestProbability:"
  
  if (is.null(probabilities)) {
    stop(paste(base.error.message, "probabilities was NULL"))
  }
  
  if ( ! is.matrix(probabilities)) {
    stop(paste(base.error.message, "probabilities has to be a matrix"))
  }
  
  if (ncol(probabilities) != 8) {
    stop(paste(base.error.message, "probabilities has to have 8 columns"))
  }
  
  if (nrow(probabilities) < 1) {
    stop(paste(base.error.message, "probabilities has to have at least one row"))
  }
  
  if ( ! is.numeric(probabilities)) {
    stop(paste(base.error.message, "probabilities has to be of type numeric"))
  }
  
  if (min(probabilities) < 0 | max(probabilities) > 1) {
    stop(paste(base.error.message, "values in probabilities has to be between 0 and 1"))
  }
}

VerifyArgumentsFor_SelectCategory_WeightedAverage <- function(probabilities) {
  # Helper function that checks if the input to SelectCategory_WeightedAverage are valid.
  
  base.error.message <- "Invalid argument to SelectCategory_WeightedAverage:"
  
  if (is.null(probabilities)) {
    stop(paste(base.error.message, "probabilities was NULL"))
  }
  
  if ( ! is.matrix(probabilities)) {
    stop(paste(base.error.message, "probabilities has to be a matrix"))
  }
  
  if (ncol(probabilities) != 8) {
    stop(paste(base.error.message, "probabilities has to have 8 columns"))
  }
  
  if (nrow(probabilities) < 1) {
    stop(paste(base.error.message, "probabilities has to have at least one row"))
  }
  
  if ( ! is.numeric(probabilities)) {
    stop(paste(base.error.message, "probabilities has to be of type numeric"))
  }
  
  if (min(probabilities) < 0 | max(probabilities) > 1) {
    stop(paste(base.error.message, "values in probabilities has to be between 0 and 1"))
  }
}

VerifyArgumentsFor_SelectCategory_Loess <- function(probabilities, span.setting) {
  # Helper function that checks if the input to SelectCategory_Loess are valid.
  
  base.error.message <- "Invalid argument to SelectCategory_Loess:"
  
  if (is.null(probabilities)) {
    stop(paste(base.error.message, "probabilities was NULL"))
  }
  
  if ( ! is.matrix(probabilities)) {
    stop(paste(base.error.message, "probabilities has to be a matrix"))
  }
  
  if (ncol(probabilities) != 8) {
    stop(paste(base.error.message, "probabilities has to have 8 columns"))
  }
  
  if (nrow(probabilities) < 1) {
    stop(paste(base.error.message, "probabilities has to have at least one row"))
  }
  
  if ( ! is.numeric(probabilities)) {
    stop(paste(base.error.message, "probabilities has to be of type numeric"))
  }
  
  if (min(probabilities) < 0 | max(probabilities) > 1) {
    stop(paste(base.error.message, "values in probabilities has to be between 0 and 1"))
  }
  
  if (is.null(span.setting)) {
    stop(paste(base.error.message, "span.setting was NULL"))
  }
  
  if ( ! is.vector(span.setting)) {
    stop(paste(base.error.message, "span.setting has to be a vector"))
  }
  
  if (length(span.setting) != 1) {
    stop(paste(base.error.message, "span.setting has to exactly one value"))
  }
  
  if ( ! is.numeric(span.setting)) {
    stop(paste(base.error.message, "span.setting has to be of type numeric"))
  }
  
  if (span.setting < 0) {
    stop(paste(base.error.message, "values in probabilities has to be between 0 and 1"))
  }
}

VerifyArgumentsFor_CreateLoessSelectionGraph <- function(patient.category.probabilities, span.setting) {
  # Helper function that checks if the input to CreateLoessSelectionGraph are valid.
  
  base.error.message <- "Invalid argument to CreateLoessSelectionGraph:"
  
  if (is.null(patient.category.probabilities)) {
    stop(paste(base.error.message, "patient.category.probabilities was NULL"))
  }
  
  if ( ! is.vector(patient.category.probabilities)) {
    stop(paste(base.error.message, "patient.category.probabilities has to be a vector"))
  }
  
  if (length(patient.category.probabilities) != 8) {
    stop(paste(base.error.message, "patient.category.probabilities has to have 8 values"))
  }
  
  if ( ! is.numeric(patient.category.probabilities)) {
    stop(paste(base.error.message, "patient.category.probabilities has to be of type numeric"))
  }
  
  if (min(patient.category.probabilities) < 0 | max(patient.category.probabilities) > 1) {
    stop(paste(base.error.message, "values in patient.category.probabilities has to be between 0 and 1"))
  }
  
  if (is.null(span.setting)) {
    stop(paste(base.error.message, "span.setting was NULL"))
  }
  
  if ( ! is.vector(span.setting)) {
    stop(paste(base.error.message, "span.setting has to be a vector"))
  }
  
  if (length(span.setting) != 1) {
    stop(paste(base.error.message, "span.setting has to exactly one value"))
  }
  
  if ( ! is.numeric(span.setting)) {
    stop(paste(base.error.message, "span.setting has to be of type numeric"))
  }
  
  if (span.setting < 0) {
    stop(paste(base.error.message, "values in probabilities has to be between 0 and 1"))
  }
}
